# Loki как источник логов

## Общая модель: логи как помеченные потоки

Loki концептуально похож на Prometheus, но для логов:

- логи группируются в **streams** — потоки с одинаковым набором меток (labels);  
- каждая запись — это пара `(timestamp, line)`;  
- вместо временных рядов чисел — временные ряды строк.

Grafana через datasource Loki отправляет HTTP‑запросы к API Loki, используя язык запросов LogQL.

Упрощённый ответ Loki:

```json
{
  "status": "success",
  "data": {
    "resultType": "streams",
    "result": [
      {
        "stream": {
          "job": "my_service",
          "instance": "app-1:8080",
          "level": "error"
        },
        "values": [
          ["1710000000000000000", "ERROR failed to handle request id=123"],
          ["1710000005000000000", "ERROR db timeout for user=42"]
        ]
      }
    ]
  }
}
```

Grafana интерпретирует это как:

- набор лог‑строк с временными метками и метаданными (лейблы);  
- отображает их в лог‑панели с фильтрами, подсветкой и поиском.

## Подключение Loki к Grafana

При добавлении Loki‑datasource указываются:

- URL Loki (например, `http://loki:3100`);  
- режим доступа (через backend Grafana);  
- настройки аутентификации/HTTP.

Дальше в панелях можно:

- писать запросы на LogQL;  
- использовать те же переменные, что и для Prometheus (namespace, pod, app и т.п.);  
- строить панели типа «Logs» и комбинированные панели (logs + метрики).

## Язык запросов LogQL: фильтрация по label’ам и тексту

LogQL делится на:

- **лог‑запросы** (log queries) — возвращают строки логов;  
- **метрические запросы** (metric queries) — агрегируют логи в числовые временные ряды (например, количество ошибок в минуту).

Пример лог‑запроса:

```js
{job="my_service", level="error"} |= "timeout"
```

Здесь:

- `{job="my_service", level="error"}` — фильтр по меткам (labels);  
- `|= "timeout"` — текстовая фильтрация по строке лога.

Пример метрического запроса:

```js
sum by (status_code) (
  rate({job="my_service"} |= "HTTP" | regexp "status=(\\d+)" [5m])
)
```

Loki в этом случае:

- берёт логи, отфильтрованные по label’ам и тексту;  
- по регулярке вытаскивает `status_code`;  
- считает rate/количество за интервал;  
- возвращает уже числовые ряды, с которыми Grafana работает как с обычными метриками.

## Формат данных и парсинг логов

Loki принимает и хранит сырые строки логов, а парсинг может происходить:

- на этапе ingestion (на стороне агента / promtail / vector / fluent‑bit);  
- на этапе запроса (через операторы LogQL: `| json`, `| regexp`, `| pattern` и т.п.).

Примеры:

```js
{job="my_service"} | json | line_format "{{ .method }} {{ .path }} {{ .status }}"
```

Здесь:

- `| json` говорит Loki попытаться разобрать строку как JSON‑объект;  
- дальше поля JSON можно использовать в фильтрах и форматировании.

Grafana отображает:

- столбец с временной меткой;  
- столбец с лог‑строкой (возможно — в переработанном формате);  
- опционально — отдельные выделенные поля (level, msg, trace_id, user_id и т.п.).

## Связка метрик и логов

Типичный сценарий:

- по графику метрик (Prometheus) видно, что в 10:05 резкий скачок ошибок;  
- в Grafana можно кликнуть по точке и перейти к логам Loki за соответствующий интервал и с нужными label’ами (например, `namespace`, `pod`, `service`);  
- если в логах есть `trace_id`/`request_id`, их можно использовать для дальнейшей корреляции с трейсовыми системами.

Это делается через:

- label‑фильтры (одинаковые метки для метрик и логов: `pod`, `namespace`, `service`);  
- шаблонные переменные на дашборде, которые одновременно подставляются в запросы PromQL и LogQL.
