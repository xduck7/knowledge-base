# Jaeger как источник метрик

## Общая модель: трейсы как структурированные события

Jaeger не передаёт метрики напрямую. Он формирует **трейсы** — разрозненные фрагменты информации о прохождении запроса сквозь систему. Каждый запрос — это **trace**, состоящий из **spans**. Каждый span содержит:

* временные метки начала и конца;
* имя операции;
* метки (tags);
* логи внутри спана;
* контекст для корреляции (trace_id, span_id).

Эти данные не являются временными рядами. Для получения метрик используется **агрегация на стороне хранилища или сторонних систем**. Jaeger передаёт сырой поток трейсов, а метрики извлекаются из них другими компонентами.

Упрощённый span:

```json
{
  "traceID": "abc123",
  "spanID": "xyz789",
  "operationName": "db.query",
  "startTime": 1710000000000000,
  "duration": 25000,
  "tags": [
    {"key": "service.name", "value": "my_service"},
    {"key": "span.kind", "value": "server"},
    {"key": "db.statement", "value": "SELECT * FROM users"}
  ]
}
```

## Как Jaeger отдаёт данные наружу

Jaeger-collector принимает трейсы от агентов или SDK. Далее существуют пути:

1. Хранение в backend (Elasticsearch, ClickHouse, Tempo).
2. Экспорт во внешние системы через OTEL-pipeline.
3. Индексация и агрегация для метрик.

Графана подключается не к самому Jaeger, а к **хранилищу трейсов** или к **OpenTelemetry Collector**, который превращает трейсы в метрики.

## Путь метрик через OpenTelemetry Collector

Для метрик используется механизм **span metrics**. Collector получает трейсы и создаёт:

* длительность операций;
* количество вызовов;
* распределения ошибок;
* latency-гистограммы.

Эти данные превращаются в Prometheus-совместимые ряды.

Пример конфигурации spanmetrics:

```yaml
processors:
  spanmetrics:
    metrics_exporter: prometheus
    latency_histogram:
      buckets: [10ms, 50ms, 100ms, 250ms, 500ms, 1s]
    dimensions:
      - service.name
      - operation
      - status.code
```

Collector после обработки отдаёт данные в Prometheus.

## Что получает Grafana

После преобразования трейсов в метрики Grafana работает с ними как с обычными временными рядами:

* `trace_requests_total{service="my_service"}`
* `trace_request_latency_bucket{service="my_service", le="0.5"}`
* `trace_errors_total{service="my_service"}`

Это стандартные Prometheus-метрики. Источник — не Jaeger напрямую, а слой агрегации.

## Экспорт напрямую из Jaeger

Jaeger может публиковать собственные служебные метрики:

* количество обработанных спанов;
* задержки ingestion;
* состояние очередей;
* нагрузку на indexing backend.

Эти метрики публикуются обычным Prometheus endpoint самого Jaeger и используются для мониторинга Jaeger как сервиса, а не данных трейсинга.

## Корреляция логов, метрик и трейсов

Визуализация в Grafana строится вокруг trace_id. Метрики дают общую картину нагрузки, трейсы раскрывают структуру запроса, а логи дополняют деталями. Переходы:

* метрика → список трейсов за интервал;
* trace → разбор спанов;
* span → связанный лог с тем же trace_id.

Это создаёт единый рабочий контур наблюдаемости.