### Общие best practices Grafana

* Хранить конфиги Grafana как код: provisioning для datasources, дашбордов, алертов; JSON дашбордов и `values.yaml`/`grafana.ini` в Git; деплой через CI/CD.
* Разделять окружения (dev/stage/prod) через отдельные организации, папки или инстансы Grafana, чтобы эксперименты не затрагивали прод.
* Делать минимальный RBAC: dev имеет editor-права на своих дашбордах, продовые обзорные дашборды — read-only, админов — ограниченное количество.

### Дизайн дашбордов

* Каждый дашборд предназначен под конкретную задачу: дашборд сервиса, кластера, базы данных, а не свалка всего.
* На одном дашборде разумно держать 5–20 панелей; огромные полотна дробить на несколько сценарных страниц.
* Наверху — ключевые SLI/SLO (ошибки, латентность, RPS), ниже — детализация по endpoint или instance, внизу — логи и трейсы.

### Prometheus: метрики и запросы

* Не помещать в label’ы высокую кардинальность (user_id, request_id, raw URL); использовать нормализованные значения (path pattern, service, env).
* Применять recording rules для тяжёлых запросов и предагрегаций, чтобы не перегружать Prometheus.
* В запросах использовать `rate` или `irate`, а также агрегации `sum by(...)` и `avg by(...)` вместо сырых `*_total`.

### Loki: логи и запросы

* Нормализовать набор label’ов потоков логов: `job`, `instance`, `namespace`, `service`, `pod`, `env`.
* По возможности переносить парсинг логов (JSON, паттерны) на ingestion-уровень — promtail, vector, fluent-bit — чтобы не выполнять тяжёлые операции в LogQL.
* Для анализа трендов и алертинга применять метрические LogQL-запросы (count, rate), а не только поиск по строкам.

### PostgreSQL и postgres-exporter

* Разделять роли: postgres-exporter собирает техметрики (stat-представления, perf, health) для Prometheus; PostgreSQL-datasource в Grafana используется для бизнес-аналитики через SQL.
* postgres-exporter должен работать от отдельного read-only пользователя с минимальными правами и чётко определёнными кастомными запросами.
* В SQL для бизнес-дашбордов использовать макросы Grafana (`$__timeFilter`, `$__interval`) и агрегировать по времени на стороне БД вместо передачи сырых событий.

### Алертинг

* Основывать алерты на SLO/SLI: latency, error-rate, availability, а не на отдельных ресурсных метриках без контекста.
* Настраивать routing: разные severity направлять в разные каналы (онколл, Slack, почта), иметь временные окна тишины.
* Уменьшать шум: алерты должны требовать действия; всё остальное держать на дашбордах.

### Наблюдаемость самой Grafana

* Включить собственные метрики Grafana и построить дашборд её состояния: ошибки запросов к datasources, latency, нагрузка на базу данных Grafana.
* Следить за ростом количества дашбордов и панелей, регулярно очищать неиспользуемые и экспериментальные.

### Безопасность и эксплуатация

* Менять дефолтный admin/admin, включать HTTPS (через reverse-proxy или встроенный TLS), отключать анонимный доступ при отсутствии необходимости.
* Перед обновлением Grafana изучать release notes, прогонять апгрейд на stage, делать бэкап БД и конфигов.
* Хранить чувствительные данные (пароли datasources, API-ключи) в секретах — Kubernetes secrets, Vault, env-секретах — а не в открытом `grafana.ini` в Git.
