### Жизненный цикл релиза

Релиз — это версия развёрнутого чарта в Kubernetes. Helm хранит все ревизии релиза в своём storage-бекенде и рассматривает каждое изменение как новую ревизию. Релиз определяется именем, чартом, значениями и набором созданных ресурсов.

`helm upgrade --install` совмещает установку и обновление. Если релиза нет — создаётся новая ревизия и применяется полный набор ресурсов. Если релиз существует — Helm вычисляет дифф между текущими ресурсами и рендером обновлённого чарта, затем применяет патчи. Такой подход выравнивает поведение install/upgrade и убирает необходимость вручную проверять существование релиза.

История хранится как последовательность ревизий. Каждая ревизия содержит рендер шаблонов, набор значений и статусы применения. История позволяет анализировать изменения и даёт возможность возвращаться к прошлым состояниям.

`helm rollback` возвращает релиз к любой ревизии. Helm берёт шаблоны и значения старой ревизии, рендерит их и применяет как новое изменение, формируя очередную ревизию. Откат не стирает историю, он записывает новое состояние, основанное на предыдущем.

Идемпотентность опирается на фиксированное описание состояния: чарт + values → предсказуемый результат без побочных эффектов. При неизменных значениях и шаблонах повторный upgrade приводит к тем же YAML-манифестам. Это исключает дрейф конфигурации и делает релизы воспроизводимыми.

---

### Зависимости и subcharts

Чарт может включать зависимости через указание списка в `Chart.yaml`. При `helm dependency update` Helm скачивает внешние чарты в директорию `charts/`. Эти зависимости рендерятся как часть основного чарта, но остаются самостоятельными компонентами.

Модель subchart используется, когда логически независимый компонент должен разворачиваться вместе с основным чартом, но управляться параметрами отдельно. Типичный пример — общий nginx в качестве reverse-proxy, redis как кеш, Sidecar-компоненты, вспомогательные сервисы. Subchart имеет собственные значения, собственный набор шаблонов и может переиспользоваться в других проектах.

Выделение subchart оправдано, когда компонент независим, переиспользуем, обновляем отдельно и имеет собственную зону ответственности. Если компонент тесно связан с основной логикой и используется только в одном сервисе, его можно оставить частью основного чарта.

Повторное использование достигается через единые чарты инфраструктурных компонентов. Один и тот же redis-чарт, nginx-чарт или internal-utility-чарт подключается в разные сервисы, обеспечивая одинаковое поведение и настройки. Это исключает дублирование YAML и снижает вероятность расхождений между компонентами.
