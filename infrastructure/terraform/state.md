# Terraform state

## Что такое state и зачем он нужен

Terraform state — это файл `terraform.tfstate`, в котором хранится текущее представление инфраструктуры глазами Terraform.  
В нём описано, какие ресурсы уже созданы, их реальные ID в провайдерах, текущие атрибуты и связи между ними.  

State нужен, чтобы:

- сопоставлять декларативный конфиг с реальными ресурсами;  
- понимать, что нужно создать, изменить или удалить при `plan/apply`;  
- не пытаться каждый раз создавать всё заново.  

Без state Terraform не знал бы, какие ресурсы уже существуют, а какие только описаны в конфиге.

---

## Как устроен tfstate

Файл состояния:

- по умолчанию называется `terraform.tfstate`;  
- представляет собой JSON со списком ресурсов, их типом, адресом (`aws_instance.app`) и текущими атрибутами;  
- создаётся после первого `terraform apply` и обновляется при каждом успешном изменении.  

Упрощённо там лежит:

- список ресурсов (resource instances) и зависимостей;  
- значения всех атрибутов, которые Terraform получил от провайдера;  
- служебная информация (версия state, версия Terraform, provider schema).  

Terraform использует этот снимок как «истину» о том, что он считает развёрнутым.

---

## Как Terraform использует state

При `terraform plan/apply` Terraform делает три шага:

1. Читает конфигурацию (`.tf` файлы) — **желаемое состояние**.  
2. Читает `terraform.tfstate` — **известное состояние**.  
3. Для каждого ресурса опрашивает провайдер (через API), чтобы сверить state с реальностью (drift).  

Дальше:

- строится diff: что нужно создать/обновить/удалить;  
- этот diff выводится в `plan`;  
- при `apply` Terraform выполняет операции и в конце обновляет state.  

Если поменять ресурс только руками в консоли облака:

- state останется старым;  
- при следующем планe Terraform увидит расхождение (drift) и предложит изменения, чтобы вернуть систему к декларируемому состоянию.

---

## Локальный vs удалённый state

### Локальный state

По умолчанию state хранится локально, в файле `terraform.tfstate` в директории проекта.

Плюсы:

- просто стартовать (никакой доп. настройки);  
- удобно для локальных экспериментов и pet‑проектов.  

Минусы:

- нельзя безопасно работать командой (каждый будет иметь свой локальный state);  
- легко потерять/сломать файл;  
- нет централизованного lock’а (можно параллельно запустить `apply` из двух мест).  

### Удалённый state (remote backend)

В проде почти всегда используют **remote backend**:

- Amazon S3 / GCS / Azure Storage / Yandex Object Storage;  
- Terraform Cloud / Terraform Enterprise;  
- PostgreSQL, Consul, HTTP‑backend и т.п.  

Преимущества:

- один единый источник истины для всей команды;  
- блокировки (locking) на время выполнения операций, чтобы не было гонок;  
- устойчивое хранение (бэкапы, версионирование, шифрование).  

Пример backend’а (S3‑подобный, синтаксис в целом одинаковый):

```tf
terraform {
  backend "s3" {
    bucket = "my-terraform-state"
    key    = "project/prod/terraform.tfstate"
    region = "eu-central-1"
  }
}
```

После `terraform init` state будет храниться в бакете, а локально останется только служебный файл с метаданными backend’а.

---

## Безопасность и секреты в state

Важно помнить: в state попадает **много чувствительных данных**:

- пароли, токены и ключи, возвращённые ресурсами;  
- сгенерированные креды БД;  
- ARN’ы, ID, URL’ы внутренних сервисов.  

Best practices:

- всегда считать state чувствительным артефактом (как базу данных);  
- включать шифрование на уровне backend’а (S3 SSE, KMS, шифрование в Terraform Cloud и т.п.);  
- ограничивать доступ к state только тем, кому реально нужно менять инфраструктуру;  
- не коммитить `terraform.tfstate` в Git.  

---

## Drift и import

### Drift

Drift — это рассинхрон между state и реальностью:

- ресурсы меняли руками в консоли провайдера;  
- что‑то удалили/создали в обход Terraform.  

При следующем `plan`:

- Terraform, сравнив state и данные от провайдера, увидит изменения;  
- предложит привести всё к тому, что описано в конфиге (иногда создав/удалив ресурсы).  

Чем меньше ручных изменений в обход Terraform, тем проще жизнь.

### terraform import

Если ресурсы уже существуют, но не управляются Terraform:

- их можно «подтянуть» в state командой `terraform import`:  

```
terraform import aws_instance.app i-0123456789abcdef0
```

После этого:

- Terraform будет считать указанный ресурс своим;  
- нужно привести конфигурацию (`.tf`) в соответствие с реальными атрибутами (иначе план сразу покажет diff).

---

## Почему нельзя редактировать tfstate руками

Файл `terraform.tfstate` — обычный JSON, и его можно открыть любым редактором.  
Но ручное редактирование почти всегда приводит к скрытым проблемам:

- несогласованность версий и внутренних структур;  
- поломка ссылок между ресурсами;  
- расхождение со схемой провайдера.  

Terraform ожидает строгий формат, и баги в state могут выстрелить позже, при планах/апплаях.  
Правильный путь — использовать команды `terraform state` и корректировать дизайн конфигов, а не патчить JSON руками.  

---

## Сводка

- State — это снимок управляемой инфраструктуры, без него Terraform не понимает, чем он владеет и что нужно менять.  
- В проде state почти всегда выносят в удалённый backend с блокировками и шифрованием.  
- К state нужно относиться как к секретным и критичным данным, не коммитить его в репозиторий и не редактировать руками.  
- CLI‑команды для работы со state позволяют безопасно рефакторить конфигурации, импортировать существующие ресурсы и разруливать сложные кейсы.
