### Как поднять Vault локально (dev‑mode)

Для локальной разработки проще всего использовать dev‑режим: это однопроцессный Vault, который сам инициализируется, не требует unseal‑ключей, хранит всё в памяти и слушает `127.0.0.1:8200` без TLS. Такой сервер нельзя использовать в проде, но он идеален для экспериментов и локальной интеграции.

1. Установить бинарник Vault (через пакетный менеджер или с сайта HashiCorp).
2. Запустить dev‑сервер:  
   ```bash
   vault server -dev
   ```
   В выводе ты увидишь:  
   - адрес сервера, обычно `http://127.0.0.1:8200`;  
   - dev root token (например, `root` или рандомная строка) — это полный доступ.

3. В другом терминале экспортировать адрес и токен:  
   ```bash
   export VAULT_ADDR='http://127.0.0.1:8200'
   export VAULT_TOKEN='root'   # или твой dev root token
   ```
   Теперь `vault` CLI будет говорить с локальным dev‑сервером и аутентифицироваться этим токеном.

Dev‑сервер:  
- уже инициализирован и unsealed;
- хранит данные в памяти и теряет их при перезапуске;
- слушает только `127.0.0.1` и без TLS, что приемлемо локально, но не в проде.


### Sidecar‑паттерн с Vault

В Kubernetes распространён паттерн sidecar‑агента Vault: приложение вообще не знает о Vault, оно просто читает файлы/ENV, а вся работа с секретами происходит рядом, в побочном контейнере.

Выглядит это концептуально так:

1. В кластере развёрнут Vault (обычно через Helm‑чарт) плюс **Vault Agent Injector** — mutating webhook, который перехватывает создание Pod’ов.
2. Деплоймент приложения аннотируется, например:  
   ```yaml
   metadata:
     annotations:
       vault.hashicorp.com/agent-inject: "true"
       vault.hashicorp.com/role: "myapp-role"
       vault.hashicorp.com/agent-inject-secret-db: "secret/data/app/db"
   ```
   Эти аннотации говорят injector’у:  
   - нужно добавить sidecar‑контейнер с Vault Agent;  
   - нужно подтянуть секрет `secret/data/app/db` и положить его в файл.

3. Когда Kubernetes создаёт Pod, webhook меняет его манифест:  
   - добавляет init‑контейнер/sidecar Vault Agent;  
   - монтирует общий volume (например, `/vault/secrets`), расшаренный между приложением и агентом.

4. Vault Agent в sidecar’е:  
   - аутентифицируется в Vault (через Kubernetes auth, используя service account Pod’а);
   - по политикам получает доступ к `secret/data/app/db`;  
   - пишет секреты в файлы внутри volume, например `/vault/secrets/db`.
   - при ротации секретов обновляет файл (иногда через шаблоны/Consul Template), поддерживая его актуальным.

5. Приложение внутри того же Pod’а:  
   - не умеет разговаривать с Vault напрямую;  
   - просто читает файл `/vault/secrets/db` при старте или периодически (или получает конфиг через переменные окружения, которые тоже может заполнять агент);
   - с точки зрения кода — это любой конфиг‑файл или обычная операция чтения файла.  

На словах пример:

- У тебя есть деплоймент `billing-service`.  
- Ты добавляешь к Pod’у аннотации Vault injector’а, указывая, что нужен секрет `secret/data/billing/db-creds`.  
- При создании Pod’а Kubernetes автоматом втыкает sidecar‑контейнер `vault-agent` и общий volume `/vault/secrets`.  
- Vault Agent логинится в Vault по service account, вытаскивает креды к PostgreSQL и кладёт их в `/vault/secrets/db-creds`.  
- `billing-service` при старте читает этот файл, парсит строку подключения и открывает коннект к БД.  
- Когда Vault ротирует креды (динамический секрет по TTL), агент обновляет файл, а приложение может переподключиться к БД по своему механизму (или просто перезапускается RollingUpdate’ом).  

Плюсы такого подхода:

- приложение вообще не знает о Vault API, только о локальных файлах;
- секреты не светятся в манифестах, ConfigMap’ах и обычных Kubernetes Secrets;
- доступ и ротация централизованы в Vault, всё логируется и контролируется политиками.
