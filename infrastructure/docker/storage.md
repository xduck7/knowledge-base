# Хранение данных в Docker: основы и практические схемы для backend-сервисов

## Базовые варианты: bind mounts и volumes

Контейнеры считаются эфемерными: файловая система внутри них живёт только пока работает процесс. Для постоянного хранения данных требуется вынести состояние за пределы контейнера. Docker предоставляет два механизма: bind-монтирования и volumes. Оба позволяют монтировать директорию в контейнер, но имеют разную природу и поведение.

Bind mount — прямое отображение локальной директории хоста внутрь контейнера. Это гибкое решение: содержимое полностью контролируется пользователем. Применимо, когда нужны исходники, локальные конфиги, временные тестовые данные. Недостатки — зависимость от структуры хоста, риск неконсистентности, необходимость ручного управления доступами.

Volume — управляемый Docker объект, имеющий собственный lifecycle и расположение в хранилище Docker Engine. Это абстракция поверх реальной директории. Поведение предсказуемое, перемещение между хостами упрощено, использование в проде более безопасно. Docker сам создаёт, монтирует и сохраняет volume независимо от структуры хоста.

Выбор зависит от цели. Bind mounts подходят для разработки и интерактивной работы. Volumes используются для продовых сервисов, где стабильность и переносимость важнее гибкости.

---

## Хранение данных в backend-сервисах: Postgres, MySQL, Redis, ClickHouse

Контейнеризация баз данных требует аккуратного обращения с состоянием. Образ и контейнер — заменяемые сущности. Данные — нет. Стратегия одинаковая: контейнер держит процесс, volume держит состояние.

Postgres. Контейнер монтирует volume в /var/lib/postgresql/data. Все изменения файловой системы происходят в этом volume. При обновлении версии базы необходимо внимательно управлять каталогом данных, так как миграции между major-версиями требуют pg_upgrade или переноса дампа. Рекомендуется использовать официальные механизмы бэкапов: pg_dump, pg_basebackup, а также внешние snapshot-решения уровня хостовой ФС.

MySQL. Аналогичная схема: volume монтируется в /var/lib/mysql. Обновление также может требовать dump/restore или mysql_upgrade в зависимости от версии. Бэкапы обычно выполняются через mysqldump или physical copy каталога с остановленным сервером. Для контейнеризированных окружений допустимо использовать sidecar-контейнеры, выполняющие регулярные дампы в объёмное хранилище.

Redis. В зависимости от режима работы Redis может быть полностью in-memory с периодическими snapshot-ами (RDB) или журнальным AOF-логом. Контейнер монтирует volume в /data. Persistency достигается сохранением RDB/AOF в этот volume. Бэкап — это копирование этих файлов, задачи consistency при snapshot-ах решает сам Redis. При использовании AOF желательно следить за переписыванием файла и размером журнала.

ClickHouse. При работе с большим объёмом данных volume монтируется в /var/lib/clickhouse. Хранилище зависит от формата движка (MergeTree и др.), и consistency достигается механизмами самого ClickHouse. Бэкап обычно делается средствами ClickHouse: BACKUP TABLE/ DATABASE TO S3/FS или копированием директорий с предварительным SYNC. В контейнеризированных окружениях предпочтительны встроенные backup-механизмы, так как они обеспечивают целостность данных на уровне таблиц и партиций.

Контейнеры должны быть максимально заменяемыми, а volume — стабильным слоем, живущим поверх любых обновлений. Для продовых сервисов требуется внешняя система бэкапов — либо через утилиты СУБД, либо через снапшоты underlying storage, либо через регулярные sidecar-процессы. Без устойчивого хранилища и бэкапа состояние в контейнерах считается ненадёжным.
