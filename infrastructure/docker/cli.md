# Docker CLI basics: жизненный цикл контейнера

Этот файл даёт практический минимум по Docker CLI для разработки и отладки backend‑сервисов.  
Фокус: жизненный цикл контейнера и команды `docker run`, `docker ps`, `docker logs`, `docker exec`, `docker rm`.

---

## Ментальная модель: контейнер как процесс

Контейнер — это обычный процесс (или несколько процессов), запущенный в изолированном окружении из образа.  
Жизненный цикл контейнера тесно привязан к основному процессу внутри него: как только он завершился, контейнер останавливается.

Состояния контейнера:

- **created** — контейнер создан, но ещё не запущен;  
- **running** — основной процесс работает;  
- **exited** — процесс завершился (успешно или с ошибкой);  
- **dead** / **removing** — служебные состояния, обычно не нужны в базовом флоу.

---

## docker run: создать и запустить контейнер

`docker run` одновременно:

1. берёт образ (локально или через pull);  
2. создаёт на его основе контейнер;  
3. запускает основной процесс в контейнере.

### Простейший пример

```
docker run nginx
```

Что происходит:

- если локального образа `nginx` нет, он подтягивается из registry;  
- создаётся контейнер;  
- запускается `nginx` в foreground;  
- лог nginx попадает в stdout текущего терминала;  
- по `Ctrl+C` контейнер останавливается.

### Часто используемые флаги

```
docker run --name my-nginx -p 8080:80 -d nginx:alpine
```

- `--name my-nginx` — человекочитаемое имя вместо auto‑generated;  
- `-p 8080:80` — проброс порта `80` внутри контейнера на `8080` хоста;  
- `-d` — detached mode (запуск в фоне);  
- `nginx:alpine` — конкретный образ и тег.

Ещё полезные опции:

- `-e KEY=VALUE` или `--env-file .env` — окружение;  
- `-v host_path:container_path` — тома / bind mounts;  
- `--rm` — автоматически удалить контейнер после остановки (удобно для одноразовых запусков).

Пример одноразового запуска миграций:

```
docker run --rm --network my-net my-service ./migrate up
```

---

## docker ps: список контейнеров

### Бегущие контейнеры

```
docker ps
```

Выводит:

- `CONTAINER ID`  
- `NAMES`  
- `IMAGE`  
- `STATUS`  
- `PORTS`  

Полезные флаги:

- `docker ps -a` — все контейнеры, включая остановленные;  
- `docker ps --filter status=exited` — только завершённые;  
- `docker ps --filter name=my-service` — фильтрация по имени.

Примеры сценариев:

- проверить, запустился ли сервис: `docker ps | grep my-service`;  
- посмотреть, какой порт проброшен: колонка `PORTS` в `docker ps`.

---

## docker logs: посмотреть логи контейнера

Контейнер пишет stdout/stderr, Docker сохраняет их и даёт доступ через `docker logs`.

### Базовое использование

```
docker logs my-nginx
```

Покажет накопленные логи контейнера с момента запуска.

### Тейлинг и «живые» логи

```
docker logs -f my-nginx
```

- `-f` — «follow», похож на `tail -f`;  
- пригодно для live‑отладки.

Комбинация с последними N строк:

```
docker logs --tail 100 -f my-nginx
```

Полезно, когда логов много, а нужен только хвост.

---

## docker exec: выполнить команду в работающем контейнере

`docker exec` — способ попасть внутрь уже запущенного контейнера или выполнить внутри него разовую команду.  
Это основной инструмент дебага.

### Интерактивный шелл

```
docker exec -it my-nginx sh
```

- `-i` — интерактивный режим (stdin открыт);  
- `-t` — псевдотерминал (TTY);  
- `sh` или `bash` — командная оболочка внутри контейнера.

Применения:

- посмотреть файловую систему контейнера;  
- проверить конфиги и права;  
- покрутить `curl`/`ps`/`netstat` внутри контейнера.

### Разовые команды

```
docker exec my-nginx nginx -t
docker exec my-nginx ls /etc/nginx/conf.d
```

- удобно запускать проверки, миграции, вспомогательные утилиты без пересоздания контейнера.

---

## docker stop / start: остановка и запуск существующих контейнеров

`docker run` создаёт **новый** контейнер.  
Чтобы управлять уже созданным:

```
docker stop my-nginx
docker start my-nginx
```

- `docker stop` — посылает SIGTERM, ждёт (по умолчанию 10 секунд), потом SIGKILL;  
- `docker start` — запускает уже существующий контейнер с тем же конфигом (образ, тома, порты).

Сценарии:

- перезапустить сервис без пересоздания:

  ```
  docker restart my-nginx
  ```

- временно остановить контейнер, чтобы освободить ресурсы;  
- перезапустить backend после обновления env файлов (если не хочется трогать compose/k8s).

---

## docker rm: удаление контейнеров

Остановленный контейнер продолжает занимать место (метаданные + слой изменений).  
Чтобы убрать:

```
docker rm my-nginx
```

Удаляются:

- запись о контейнере (ID, имя, история статусов);  
- его writable‑слой (то, что изменялось/создавалось внутри).

Типичные паттерны:

- удалить один контейнер:

  ```
  docker stop my-nginx
  docker rm my-nginx
  ```

- удалить все остановленные контейнеры:

  ```
  docker container prune
  ```

**Важно:** `docker rm` не трогает сам образ. Образы управляются отдельными командами (`docker rmi`, `docker image rm`).

---

## Жизненный цикл контейнера: от run до rm

Практический сценарий для backend‑сервиса:

1. **Запуск:**

   ```
   docker run -d --name api -p 8080:8080 my-api:1.0.0
   ```

2. **Проверить, что контейнер живой:**

   ```
   docker ps
   ```

3. **Посмотреть логи, убедиться, что сервер поднялся:**

   ```
   docker logs -f api
   ```

4. **При необходимости зайти внутрь и посмотреть окружение/файлы:**

   ```
   docker exec -it api sh
   ```

5. **Остановить контейнер перед обновлением версии:**

   ```
   docker stop api
   ```

6. **Удалить старый контейнер (но не образ):**

   ```
   docker rm api
   ```

7. **Запустить новую версию с тем же именем:**

   ```
   docker run -d --name api -p 8080:8080 my-api:1.1.0
   ```

---

## Мини‑шпаргалка команд

```
# Запуск контейнера
docker run [options] image [cmd]

# Список контейнеров
docker ps              # только running
docker ps -a           # все

# Логи контейнера
docker logs <name>
docker logs -f <name>              # «подписаться» на логи
docker logs --tail 100 -f <name>   # только хвост

# Выполнить команду в работающем контейнере
docker exec -it <name> sh          # попасть в shell
docker exec <name> <command>       # разовая команда

# Остановить / запустить контейнер
docker stop <name>
docker start <name>
docker restart <name>

# Удалить контейнер
docker rm <name>
docker container prune             # удалить все остановленные
