# Логи, мониторинг и отладка контейнеров

Контейнер — это процесс. Отладка сводится к наблюдению за его выводом, состоянием и поведением. Базовый инструмент — журналы stdout/stderr. Docker сохраняет их локально и отдаёт по запросу.

Команда просмотра логов:

```sh
docker logs <id>
```

Потоки доступны в реальном времени через `-f`, что помогает отслеживать работу сервиса без дополнительных агентов. Логи принадлежат контейнеру, а не образу: при удалении контейнера файлы исчезают, если не используются внешние драйверы логирования.

Интерактивное подключение:

```sh
docker exec -it <id> sh
```

Это запуск нового процесса внутри существующего контейнера. Контейнер остаётся со своим entrypoint; exec не модифицирует состояние файловой системы слоя образа, все изменения происходят в верхнем read-write слое.

Команда top:

```sh
docker top <id>
```

Показывает процессы внутри контейнера. Полезно, когда сервис запускает дополнительные воркеры или вырождается в зомби-процессы.

Команда stats:

```sh
docker stats
```

Мониторинг в реальном времени: CPU, память, IO, сеть. Информация берётся из cgroups и отражает реальное потребление ресурсов.

Подключение к контейнеру — минимальный набор интроспекции. Все инструменты работают поверх Linux namespaces и не требуют особых прав кроме доступа к Docker Engine.

---

## Драйверы логирования и интеграция с Loki/ELK

Логи stdout/stderr обрабатываются лог-драйвером. По умолчанию используется json-file: Docker пишет логи в локальные файлы JSON. Это простой механизм, но он не масштабируется.

Основные драйверы:

json-file — дефолт. Хранит логи локально. Подходит для разработки.
journald — интеграция с системной подсистемой логирования.
syslog — отправка логов на внешний syslog сервер.
fluentd — передача данных в fluentd-агент.
gelf — отправка логов в Graylog.
loki — отправка логов напрямую в Loki.

Структура логов драйверов варьируется. json-file хранит каждый вывод как JSON-объект с timestamp и stream. Но продовые системы предпочитают централизованное логирование: данные сбрасываются из контейнеров в внешние хранилища.

Интеграция с Loki чаще всего делается через loki лог-драйвер. Контейнер отправляет логи напрямую в Loki, минуя файловую систему хоста. Это уменьшает IO и упрощает сбор. В случае ELK стек обычно собирает логи через filebeat или fluentd, которые читают json-file и отправляют их в Elasticsearch.

Централизованный сбор логов — обязательный слой для продовых систем, так как контейнеры могут пересоздаваться в любой момент, а значит лог должен жить вне контейнера.

---

## Healthcheck, метрики ресурсов и интеграция с Prometheus

Healthcheck — встроенный механизм Docker, позволяющий оценивать работоспособность контейнера. Инструкция в Dockerfile:

```sh
HEALTHCHECK CMD curl -f http://localhost:8080/health || exit 1
```

Docker будет периодически выполнять команду и менять статус контейнера на healthy или unhealthy. Этот статус доступен через `docker ps` и API Docker Engine. Контейнер с unhealthy статусом может автоматически перезапускаться оркестратором.

Метрики ресурсов доступны через stats. Формально Docker отдаёт значения из cgroups: CPU shares, memory usage, IO. Эти данные можно собирать либо через node-level экспортёры, либо через сторонние агенты.

Интеграция с Prometheus обычно строится на уровне хоста: node exporter отдаёт метрики контейнеров, включая их CPU, память, сеть. Вторая часть — метрики внутри приложения. Контейнер не должен скрывать их; сервис обязан самостоятельно публиковать endpoint `/metrics`, а Docker лишь передаёт порт наружу.

Схема контроля состояния контейнеров:

* healthcheck для быстрой оценки работоспособности;
* ресурсы через node exporter;
* логи через централизованный драйвер;
* метрики приложения через встроенный Prometheus endpoint.

Контейнеры не предоставляют собственную систему мониторинга. Они лишь изолируют процессы. Все механизмы наблюдения должны быть вынесены наружу.
