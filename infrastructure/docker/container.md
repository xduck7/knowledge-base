## Контейнер

Важно разделять три вещи:

- **образ (image)** — шаблон файловой системы + метаданные запуска;
- **контейнер (container)** — экземпляр образа с собственным ID, состоянием и writable‑слоем;
- **процесс** — основной процесс, который реально выполняется внутри контейнера.

Ключевые свойства контейнера:

- создаётся из конкретного образа;
- имеет уникальный `CONTAINER ID` и, опционально, имя (`--name`);
- имеет своё состояние (`created`, `running`, `exited`, и т.п.);
- изменения внутри пишутся в отдельный слой и пропадут при удалении контейнера (если не подключен том).

---

## Создание контейнеров

В повседневной жизни контейнеры могут:

- создаваться и запускаться одним вызовом `docker run`;
- сначала создаваться (`docker create`), а потом запускаться (`docker start`).

### Быстрый путь: `docker run`

```
docker run --name api -p 8080:8080 my-api:1.0.0
```

Под капотом происходит:

1. (опционально) `pull` образа, если его нет локально;
2. создание контейнера (эквивалент `docker create`);
3. запуск контейнера (`docker start`).

После завершения процесса контейнер остаётся в состоянии `exited`, и его можно:

- посмотреть в списке (`docker ps -a`);
- перезапустить (`docker start api`);
- удалить (`docker rm api`).

### Явное создание: `docker create`

```
docker create --name api -p 8080:8080 my-api:1.0.0
docker start api
```

Так редко пользуются в деве, но полезно, когда:

- контейнер нужно подготовить заранее (с конфигом, портами и т.д.);
- запускать/останавливать его многократно.

---

## Управление контейнерами: базовые команды

Минимальный набор:

```
# Список контейнеров
docker ps        # только running
docker ps -a     # все, включая exited

# Старт / стоп / рестарт
docker start <name|id>
docker stop <name|id>
docker restart <name|id>

# Удаление
docker rm <name|id>
docker container prune   # удалить все остановленные
```

Несколько практических паттернов:

- «перезапустить сервис с тем же контейнером»:

  ```
  docker restart api
  ```

- «остановить, изменить что‑то снаружи (env, volume), удалить и пересоздать»:

  ```
  docker stop api
  docker rm api
  docker run ... # новый контейнер, но с тем же именем
  ```

- «почистить мусор после экспериментов»:

  ```
  docker container prune
  ```

---

## Detached mode: запуск в фоне

По умолчанию без `-d` `docker run` привязывает stdout/stderr контейнера к текущему терминалу.
Для сервисов (особенно backend) обычно используют **detached mode**:

```
docker run -d --name api -p 8080:8080 my-api:1.0.0
```

Что даёт `-d`:

- контейнер запускается в фоне;
- терминал освобождается;
- логи можно смотреть через `docker logs`.

Типичный рабочий цикл:

```
docker run -d --name api -p 8080:8080 my-api:1.0.0
docker ps                  # убедиться, что контейнер живой
docker logs -f api         # смотреть логи
docker stop api            # остановить
docker rm api              # удалить
```

Ошибки при использовании detached:

- контейнер мгновенно умирает, а в терминале «тишина» → всегда проверять `docker ps -a` и `docker logs <name>`;
- забытый контейнер живёт в фоне, занимает порт/ресурсы → периодически проверять `docker ps`.

---

## restart policy: автоматический рестарт контейнера

`restart policy` управляет тем, будет ли Docker автоматически перезапускать контейнер, если он упал или если демон Docker перезапустился.

Политика задаётся флагом `--restart` при `docker run`:

```
docker run -d --name api --restart=always my-api:1.0.0
```

### Виды restart policy

Основные варианты:

- `no` — по умолчанию; Docker не будет сам перезапускать контейнер;
- `on-failure[:N]` — перезапускать контейнер, если процесс завершился с ненулевым кодом (ошибка); опционально ограничить количество попыток `N`;
- `always` — всегда пытаться перезапустить контейнер, вне зависимости от кода выхода;
- `unless-stopped` — как `always`, но если контейнер был остановлен руками (`docker stop`), Docker не будет поднимать его после перезапуска демона.

### Примеры

1. **Backend сервис в прод‑подобной среде:**

   ```
   docker run -d \
     --name api \
     --restart=unless-stopped \
     -p 8080:8080 \
     my-api:1.0.0
   ```

   Поведение:

   - если контейнер упал из‑за ошибки — будет перезапущен;
   - если перезапустился Docker daemon/хост — контейнер поднимется;
   - если вручную сделали `docker stop api` — не поднимется сам после перезапуска демона.

2. **Одноразовые задачи/джобы: миграции, скрипты:**

   ```
   docker run --rm --restart=no my-migrator:latest migrate up
   ```

   Тут автоматический рестарт не нужен: задача либо успешно завершается, либо валится, и это нужно увидеть и починить.

3. **Сервис, который часто падает, но не должен перезапускаться бесконечно:**

   ```
   docker run -d \
     --name api \
     --restart=on-failure:5 \
     my-api:1.0.0
   ```

   При неудачном старте будет до 5 попыток, далее контейнер останется упавшим.

---

## Примеры паттернов создания и управления

### 1. Локальная разработка backend‑сервиса

```
# Запуск дев‑версии с пробросом порта и автоудалением
docker run --rm \
  --name api-dev \
  -p 8080:8080 \
  -v $(pwd):/app \
  -w /app \
  my-api-dev:latest
```

Сценарий:

- код монтируется внутрь (`-v`), можно использовать hot reload;
- контейнер удаляется после остановки (`--rm`), не копится мусор;
- `restart policy` не задаём, потому что контейнер управляется руками.

### 2. Локальный стенд «как в проде» (но без оркестратора)

```
docker run -d \
  --name api \
  --restart=unless-stopped \
  -p 8080:8080 \
  -e ENV=staging \
  my-api:1.0.0
```

- работает в фоне (`-d`);
- поднимается после рестарта демона/хоста (`unless-stopped`);
- управляется `docker stop/start/restart`.

### 3. Обновление контейнера до новой версии образа

```
# остановить старый
docker stop api

# OPTIONAL: удалить старый контейнер
docker rm api

# подтянуть новый образ
docker pull my-api:1.1.0

# запустить новый контейнер с тем же именем
docker run -d \
  --name api \
  --restart=unless-stopped \
  -p 8080:8080 \
  my-api:1.1.0
```

Идея:

- контейнер — расходник, его не жалко удалять;
- состояние (если нужно) выносится в тома/БД, а не в контейнер.

---

## Рекомендации для backend‑разработчика

- Воспринимать контейнер как **одноразовый объект**: конфиг и состояние не должны жить только внутри него.
- Для сервисов, которые должны «жить всегда», использовать `--restart=always` или `--restart=unless-stopped`.
- Для одноразовых задач/утилит — `--rm` и без restart policy.
- В деве чаще запускать в foreground и смотреть логи напрямую; в прод‑подобной среде — `-d` и `docker logs`.
- Регулярно чистить остановленные контейнеры (`docker container prune`) и держать список живых контейнеров прозрачным (`docker ps`).
