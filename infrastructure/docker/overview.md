# Введение в Docker: образы, контейнеры, registry и отличие от виртуальных машин

## Что такое Docker

Docker — это платформа для контейнеризации, которая позволяет упаковать приложение со всеми зависимостями в изолированный контейнер и запускать его одинаково в разных средах: на ноутбуке разработчика, в CI, на серверах и в облаке.  
Контейнеры делают окружение воспроизводимым: «работает у меня» превращается в «работает везде, где есть Docker».

Основные задачи Docker:

- стандартизировать окружение для приложений;
- упростить доставку и развёртывание;
- ускорить запуск и масштабирование сервисов;
- изолировать приложения друг от друга на уровне процессов и файловой системы.

---

## Базовые термины

Вокруг Docker чаще всего используются четыре термина:

- **Image (образ)** — шаблон с файловой системой и метаданными.
- **Container (контейнер)** — запущенный экземпляр образа.
- **Registry** — хранилище образов (например, Docker Hub).
- **Docker Engine** — демон, который управляет образами и контейнерами.

Остальное — надстройки над этими базовыми сущностями.

---

## Docker image (образ)

Образ — это неизменяемый шаблон, из которого создаются контейнеры.  
Упрощённо: образ — это «снимок файловой системы + метаданные», описывающие, как запускать приложение.

Характеристики образа:

- **Слоистая структура**: образ состоит из слоёв, каждый слой — результат инструкции в Dockerfile.  
- **Неизменяемость**: образ после сборки не меняется; любые изменения происходят в контейнере поверх образа.  
- **Повторное использование**: слои кешируются и переиспользуются между образами, что ускоряет сборку и экономит место.  
- **Тегирование**: образы идентифицируются по `name:tag` (например, `my-service:1.2.3`, `postgres:16-alpine`).

Чаще всего образ собирается из `Dockerfile` командой вроде:

```
docker build -t my-service:1.0.0 .
```

---

## Docker container (контейнер)

Контейнер — это запущенный экземпляр образа.  
Если образ — это бинарник, то контейнер — это процесс (или набор процессов), который этот бинарник выполняет в изолированном окружении.

Особенности контейнера:

- использует файловую систему образа + «тонкий» слой для изменений (copy-on-write);
- изолирован по PID, сети, файловой системе, юзерам и т.д. (namespaces, cgroups);
- может иметь лимиты по CPU, памяти, количеству процессов;
- живёт ровно столько, сколько живёт основной процесс в контейнере.

Типичный запуск контейнера:

```
docker run --rm -p 8080:8080 my-service:1.0.0
```

Здесь:

- `my-service:1.0.0` — образ, из которого создаётся контейнер;
- контейнер получает свой ID, файловую систему, сетевой namespace и т.п.;
- маппится порт `8080` хоста на `8080` внутри контейнера.

Важно: контейнер *не* «содержит в себе образ», он создан *из* образа.  
Образ — это шаблон; контейнер — его живой экземпляр.

---

## Docker registry

Registry — это хранилище Docker‑образов, аналог Git‑репозитория, но для образов.

Основные варианты:

- публичные: Docker Hub, GitHub Container Registry, GitLab Registry, Quay и т.д.;
- приватные: self‑hosted Registry, регистри в облаках (ECR, GCR, ACR и др.).

Типичные операции:

- **pull** — забрать образ из registry на хост:

  ```
  docker pull nginx:alpine
  ```

- **push** — отправить собранный локально образ в registry:

  ```
  docker tag my-service:1.0.0 my-registry.example.com/my-service:1.0.0
  docker push my-registry.example.com/my-service:1.0.0
  ```

Связка:

- разработчик/CI собирает образ;
- пушит в registry;
- прод/стейдж окружения делают `pull` и запускают контейнеры из нужных тегов.

---

## Как это связано между собой

Краткая цепочка:

1. Пишем `Dockerfile` для приложения.  
2. Собираем из него **образ** (`docker build`).  
3. Отправляем образ в **registry** (`docker push`).  
4. На целевом хосте делаем `docker pull` и создаём **контейнеры** из нужной версии образа (`docker run`, `docker compose up`, orchestrator и т.д.).

Таким образом, образ — единица поставки, контейнер — единица выполнения.

---

## Отличие Docker/контейнеров от виртуальных машин

И Docker/контейнеры, и виртуальные машины решают задачу изоляции, но на разных уровнях.

### Как устроена виртуальная машина

При аппаратной виртуализации:

- есть гипервизор (например, VMware, Hyper‑V, KVM);
- поверх гипервизора поднимаются **полноценные ОС** (Guest OS) со своим ядром;
- в каждой ВМ внутри устанавливаются приложения.

Слои примерно такие:

- физическое железо  
- хостовая ОС / гипервизор  
- гостевые ОС (каждая со своим ядром)  
- приложения внутри каждой гостевой ОС

Особенности:

- высокая степень изоляции (отдельные ядра, драйверы, стек ОС);
- тяжёлый старт (секунды/минуты для загрузки ОС);
- существенные накладные расходы по памяти и CPU;
- сложнее быстро масштабировать малые сервисы.

### Как устроены Docker‑контейнеры

В случае Docker:

- есть хостовая ОС с ядром;
- Docker использует возможности ядра (namespaces, cgroups, overlay‑fs) для изоляции процессов;
- **контейнеры разделяют одно ядро**, а изолируются на уровне процессов и ресурсов.

Слои:

- физическое железо  
- хостовая ОС (ядро)  
- Docker Engine  
- контейнеры (процессы приложений + файловые системы образов)

Особенности:

- старт за миллисекунды/секунды (по сути старт процесса);
- гораздо меньше накладных расходов;
- удобно запускать десятки и сотни контейнеров на одном хосте;
- проще доставлять обновления (смена образа → новые контейнеры).

### Ключевые отличия в формате TL;DR

- ВМ эмулирует **целый компьютер** с отдельной ОС; контейнер — **отдельный процесс/набор процессов**, изолированный на уровне ядра.  
- ВМ тяжёлые и медленно стартуют, контейнеры лёгкие и запускаются очень быстро.  
- ВМ хорошо подходят для сильной изоляции разных ОС и «тяжёлых» окружений; контейнеры — для микросервисов и современных CI/CD‑пайплайнов.

---

## Когда что использовать

Примерные ориентиры (без фанатизма):

- Использовать **Docker/контейнеры**, когда:
  - нужен быстрый запуск и масштабирование сервисов;
  - один и тот же backend нужно запускать в разных окружениях;
  - команда строит CI/CD и микросервисную архитектуру;
  - важна плотность размещения сервисов на хостах.

- Использовать **ВМ**, когда:
  - требуется жёсткая изоляция на уровне ОС (разные ядра, разные дистрибутивы);
  - нужно запускать нестандартные/legacy окружения;
  - ограничения политики безопасности запрещают шэрить одно ядро между клиентами.

---

## Итог

- Docker — платформа контейнеризации, которая позволяет упаковывать приложения в образы и запускать их как контейнеры.  
- Образ — неизменяемый шаблон; контейнер — запущенный экземпляр образа.  
- Registry — хранилище образов и точка интеграции с CI/CD.  
- В отличие от виртуальных машин, контейнеры делят одно ядро хоста, что делает их лёгкими, быстрыми и удобными для современных backend‑архитектур.