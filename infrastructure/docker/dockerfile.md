# Dockerfile

Dockerfile описывает процесс сборки образа пошаговыми инструкциями.
Каждая инструкция формирует слой. Порядок и неизменяемость слоёв определяют воспроизводимость и размер итогового образа.

Структура типового Dockerfile:

* базовый образ через FROM;
* установка зависимостей и окружения через RUN;
* копирование исходников и артефактов через COPY;
* описание команды запуска через CMD или ENTRYPOINT;
* метаданные через LABEL, ENV, EXPOSE и другие инструкции.

Основные инструкции:

FROM — базовый слой, от которого наследуется файловая система. Может быть указано несколько раз при multi-stage.

RUN — выполняет команду в окружении слоя и сохраняет изменения в новый слой. Для установки пакетов, сборки артефактов, настройки системы.

COPY — копирует файлы из контекста в файловую систему образа. Триггерит инвалидацию кэша при любом изменении копируемых файлов.

CMD — команда по умолчанию при запуске контейнера. Может быть перезаписана аргументами docker run. Не создаёт слой.

ENTRYPOINT — главный исполняемый процесс контейнера. Заставляет контейнер вести себя как конкретное приложение. Можно сочетать ENTRYPOINT и CMD: первый определяет бинарник, второй — аргументы.

Dockerfile — декларация файловой системы и запуска. Понимание базовых инструкций определяет предсказуемость поведения при сборке и запуске.

---

Multi-stage позволяет использовать несколько стадий сборки в одном Dockerfile.
Это уменьшает размер итогового образа, устраняет dev-зависимости и отделяет build-time окружение от runtime.

Схема:

* первая стадия: heavy builder (golang, node, maven, gradle, rust);
* промежуточные стадии для тестов, линтеров, генераторов;
* финальная стадия: минимальный runtime (alpine, distroless, scratch).

Примеры:

Go — собирается в стадии builder, затем бинарник копируется в scratch или distroless.

Node — установка npm/yarn зависимостей в builder-е, сборка frontend или backend, перенос только артефактов.

Java — gradle/maven wrapper в builder-е, итоговый jar передаётся в distroless/java или slim-образ.

Преимущества multi-stage:

* радикальное уменьшение размера финального образа;
* снижение attack surface;
* reproducible build — build-time и runtime разделены;
* быстрые rebuild благодаря кэшированию стадий.

Multi-stage — ключевой механизм для продовых образов, исключающий мусор из среды сборки.

---

Критерии: статическая сборка, минимальная поверхность, предсказуемый runtime, отсутствие лишних библиотек.
Go упрощает задачу, так как позволяет собирать статические бинарники без CGO.

Базовый подход:

* сборка в golang:alpine или golang:latest;
* отключение CGO для чистой статической линковки;
* копирование бинарника в финальный distroless или scratch;
* запуск под непривилегированным uid/gid.

Пример:

```dockerfile
FROM golang:1.22 AS builder
WORKDIR /app

ENV CGO_ENABLED=0 GOOS=linux GOARCH=amd64
COPY go.mod go.sum ./
RUN go mod download

COPY . .
RUN go build -o service .

FROM gcr.io/distroless/static:nonroot
USER nonroot:nonroot
COPY --from=builder /app/service /service
ENTRYPOINT ["/service"]
```

Особенности:

* distroless → нет shell, нет package manager, минимальная поверхность атаки;
* alpine как runtime лучше избегать при статической сборке без musl;
* uid/gid nonroot уменьшает ущерб от возможной компрометации;
* при необходимости CGO требуется базовый образ со стабильной glibc и runtime-библиотеками.

Финальный образ содержит только бинарник и метаданные.

---

Полезные практики для стабильных reproducible Dockerfile:

Кэш слоёв:

* инструкции с высокой изменчивостью должны быть ниже (COPY . . → ближе к концу);
* docker build кэширует по содержимому файлов и тексту инструкции;
* аккуратное использование RUN apt-get update && apt-get install — с pin-версиями пакетов.

Порядок:

* сначала COPY только go.mod / package.json / pom.xml для установки зависимостей;
* затем установка зависимостей;
* затем COPY . .;
* затем сборка и подготовка артефактов.

.dockerignore:

* исключить всё, что не нужно для сборки: .git, build-артефакты, окружение;
* уменьшает размер контекста;
* уменьшает инвалидацию кэша.

Idempotent сборка:

* RUN инструкции не должны зависеть от случайных внешних изменений без version pinning;
* build должен давать идентичные результаты при одинаковом контексте;
* отсутствие временных данных в финальном образе.

Best practices формируют стабильный воспроизводимый образ и ускоряют pipeline.

---

docker buildx — расширение builder-а, позволяющее Multi-Arch, кеширование, параллельные контексты, build-kit.

Функции:

Кросс-платформенная сборка:

```
docker buildx build --platform linux/amd64,linux/arm64 -t my/service:1.0.0 .
```

BuildKit под капотом использует QEMU для эмуляции или native builders при наличии.

Build args:

```
ARG VERSION
ARG TARGETOS
ARG TARGETARCH
```

Используются для настройки процесса сборки, но не попадают в финальный runtime.

Target stages:

```
docker build --target builder .
docker build --target production .
```

Позволяет запускать конкретный этап multi-stage для теста или быстрой локальной сборки.

Buildx cache:

```
docker buildx build --cache-from ... --cache-to ...
```

Позволяет использовать внешний remote cache в CI, что ускоряет сборку.

Build techniques позволяют собирать portable и оптимизированные образы под разные среды.
