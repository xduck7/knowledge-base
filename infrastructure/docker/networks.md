# Сети

## Зачем вообще разбираться в сетях Docker

Для backend‑сервисов важно понимать, как контейнеры общаются друг с другом и с внешним миром.
Сетевой драйвер определяет, какие адреса и порты видит контейнер, как идут пакеты, и где нужна явная публикация портов.

В базовом Docker есть три часто используемых типа сетей:

- `bridge` — дефолтный режим для одиночных контейнеров, свой внутренний IP, NAT наружу;
- `host` — контейнер делит сетевой стек с хостом, без отдельного IP;
- `none` — сеть полностью отключена, только `lo`.

---

## Тип сети: bridge

`bridge` — это виртуальный свитч на хосте, к которому подключаются контейнеры.
По умолчанию Docker создаёт сеть `bridge`, и все контейнеры без явной сети попадают туда.

Характеристики:

- у каждого контейнера свой внутренний IP;
- контейнеры на одном bridge могут общаться друг с другом по IP/имени;
- доступ наружу (в интернет) есть через NAT;
- чтобы сервис был доступен снаружи, нужно явно публиковать порты (`-p` / `--publish`).

Примеры:

```sh
# Создать пользовательскую bridge-сеть
docker network create my-net

# Запустить два контейнера в одной сети
docker run -d --name api --network my-net my-api:1.0.0
docker run -d --name redis --network my-net redis:7

# Контейнер api может обратиться к redis по hostname "redis" и порту 6379
```

Рекомендация: для приложений из нескольких сервисов почти всегда использовать **user-defined bridge** вместо дефолтной `bridge` — там есть нормальный DNS по именам контейнеров.

---

## Тип сети: host

`host` означает, что контейнер использует сетевой namespace хоста.
Контейнер **не получает отдельный IP**, а делит интерфейсы и порты с системой.

Особенности:

- сервис в контейнере слушает «как будто» напрямую на хосте (например, `localhost:8080`);
- не нужна публикация портов (`-p`), контейнер видит все интерфейсы хоста;
- нет сетевой изоляции между хостом и контейнером;
- возможны конфликты портов с другими приложениями/контейнерами.

Пример:

```sh
docker run --network host my-api:1.0.0
```

Когда это бывает полезно:

- когда критична производительность/latency (минимум накладных расходов);
- когда приложение ожидает прямой доступ к сетевому стеку хоста (кастомный routing, multicast и т.д.);
- когда тяжело/невозможно пробрасывать порты (сложная сетка/iptables).

Но чаще всего для обычных backend‑сервисов достаточно `bridge`.

---

## Тип сети: none

`none` полностью отключает сеть контейнера.
Внутри останется только `lo` (loopback), никаких внешних интерфейсов.

Пример:

```sh
docker run --network none my-job:latest
```

Использование:

- изолированные джобы, которым не нужен сетевой доступ;
- повышенная безопасность (минимизировать поверхность атаки);
- локальное тестирование кода, который должен работать без сети.

---

## Порты и port publishing

В режиме `bridge` контейнер по умолчанию **не доступен снаружи**, даже если сервис слушает `0.0.0.0:8080` внутри.
Для доступа с хоста/внешней сети нужно опубликовать порт.

### Публикация порта

```sh
docker run -d \
  --name api \
  --network my-net \
  -p 8080:8080 \
  my-api:1.0.0
```

Семантика:

- `-p HOST_PORT:CONTAINER_PORT`;
- `8080:8080` — порт 8080 на хосте → порт 8080 внутри контейнера.

Можно указывать IP:

```sh
# Слушать только на 127.0.0.1 хоста
docker run -d -p 127.0.0.1:8080:8080 my-api:1.0.0
```

Это удобно, если хочешь, чтобы сервис был доступен только локально (например, только через SSH‑tunnel / reverse proxy).

---

## Какой тип сети выбирать

- **`bridge` (user-defined)** — дефолтный вариант для локальной разработки и мини‑стендов (app + db + cache).
- **`host`** — когда нужно «как на хосте» и устраивает отсутствие изоляции.
- **`none`** — редкий спец‑случай для задач без сети.

Обычно стек выглядит так:

- контейнеры в одной user-defined bridge‑сети;
- общение между сервисами по hostname;
- наружу торчит только один/несколько сервисов через `-p` либо через reverse proxy.

***

## Типичный backend‑стек в Docker

Частый локальный или стейджинг‑стенд:

- `app` — backend (Go, Node, etc.);
- `db` — PostgreSQL / MySQL;
- `cache` — Redis / Memcached;
- `mq` — message broker (RabbitMQ, NATS, Kafka и т.п.).

Все сервисы:

- подключены к одной user-defined bridge‑сети;
- общаются по hostnames (имена контейнеров/сервисов);
- наружу экспонируются только нужные порты.

---

## Пример: app + Postgres + Redis + RabbitMQ

Для развития логики удобно сразу показывать «как должно быть» внутри сети:

- `app` ходит в `postgres:5432`;
- `app` ходит в `redis:6379`;
- `app` ходит в `rabbitmq:5672`.

### Пример сети и запуска контейнеров «вручную»

```sh
docker network create backend-net

docker run -d \
  --name postgres \
  --network backend-net \
  -e POSTGRES_PASSWORD=secret \
  -e POSTGRES_DB=app \
  postgres:16

docker run -d \
  --name redis \
  --network backend-net \
  redis:7

docker run -d \
  --name rabbitmq \
  --network backend-net \
  rabbitmq:3-management

docker run -d \
  --name app \
  --network backend-net \
  -p 8080:8080 \
  -e DB_DSN="postgres://postgres:secret@postgres:5432/app?sslmode=disable" \
  -e REDIS_ADDR="redis:6379" \
  -e MQ_URL="amqp://guest:guest@rabbitmq:5672/" \
  my-app:latest
```

Заметьте:

- в переменных окружения используются имена контейнеров (`postgres`, `redis`, `rabbitmq`), не IP;
- это работает, потому что внутри сети `backend-net` работает встроенный DNS Docker.

---

## Паттерн: один входной point наружу

Лучше не публиковать наружу каждый сервис:

- DB/Redis/MQ обычно не нужно слушать на портах хоста в дев‑стенде;
- наружу можно вывести только:

  - backend (`-p 8080:8080`),
  - или reverse‑proxy (`nginx`, `traefik`),
  - или только admin‑интерфейс (например, RabbitMQ management).

Пример: наружу доступен только backend и RabbitMQ UI:

```
docker run -d --name rabbitmq \
  --network backend-net \
  -p 15672:15672 \   # UI
  rabbitmq:3-management
```

DB и Redis остаются доступными только из сети `backend-net`.

---

## Паттерн: несколько приложений и один общий стек

Если у тебя `api`, `worker`, `scheduler` и т.п., они могут:

- быть в одной сети `backend-net`;
- использовать одинаковые DSN/URL к `postgres`, `redis`, `mq`.

Пример:

```
docker run -d --name api --network backend-net my-api:latest
docker run -d --name worker --network backend-net my-worker:latest
docker run -d --name scheduler --network backend-net my-scheduler:latest
```

Все они:

- ходят в одну БД `postgres:5432`;
- используют один Redis `redis:6379`;
- читают/пишут одну очередь `rabbitmq:5672`.

---

## Антипаттерны и что лучше не делать

- Завязываться на IP контейнеров (они могут меняться).
- Пихать всё на `--network host` «чтобы быстрее» без необходимости.
- Публиковать наружу порты DB/Redis без нужды (лишний риск + мусор в конфиге).

Рекомендуемый шаблон:

- user-defined bridge‑сеть;
- имена сервисов как hostnames;
- наружу торчит только то, что реально нужно в браузере/клиенте.

***

## Встроенный DNS в Docker

Когда контейнеры находятся в одной user-defined bridge‑сети, Docker поднимает для них внутренний DNS.
Это позволяет обращаться к другим контейнерам по имени, а не по IP.

Поведение:

- имя по умолчанию — имя контейнера (`--name`) или имя сервиса в compose;
- DNS‑имя резолвится в внутренний IP контейнера в сети;
- если контейнер перезапустится и получит другой IP, резолвинг останется корректным.

---

## Имена контейнеров и hostname

По умолчанию:

- `--name app` задаёт имя контейнера;
- внутри той же сети к нему можно обратиться по `app`.

Пример:

```sh
docker network create backend-net

docker run -d --name postgres --network backend-net postgres:16
docker run -d --name api --network backend-net my-api:latest
```

Внутри `api`:

- хост `postgres` будет резолвиться во внутренний IP контейнера Postgres;
- подключение к БД можно настроить как:

  ```
  DB_DSN=postgres://postgres:password@postgres:5432/app?sslmode=disable
  ```

---

## Aliases: дополнительные имена сервисов

Иногда нужно дать контейнеру несколько имён в сети (например, `db` и `postgres`).
Для этого есть network‑alias.

Пример:

```sh
docker network create backend-net

docker run -d \
  --name postgres \
  --network backend-net \
  --network-alias db \
  postgres:16
```

Теперь к контейнеру можно обращаться и как `postgres`, и как `db`.

Польза:

- можно использовать более «семантичные» имена (`db`, `cache`, `mq`);
- легко подменять реализацию (например, переключить с `postgres` на `postgres-alt`, но оставить alias `db`).

---

## Docker DNS в Docker Compose

Чаще всего backend‑стек задаётся через `docker-compose.yml`.
В этом случае:

- создаётся сеть (по умолчанию `<project>_default`);
- имена сервисов становятся DNS‑именами в этой сети.

Пример compose‑файла:

```sh
version: "3.9"

services:
  postgres:
    image: postgres:16
    environment:
      POSTGRES_PASSWORD: secret
      POSTGRES_DB: app

  redis:
    image: redis:7

  mq:
    image: rabbitmq:3-management

  app:
    build: ./app
    depends_on:
      - postgres
      - redis
      - mq
    environment:
      DB_DSN: postgres://postgres:secret@postgres:5432/app?sslmode=disable
      REDIS_ADDR: redis:6379
      MQ_URL: amqp://guest:guest@mq:5672/
    ports:
      - "8080:8080"
```

Здесь:

- `postgres`, `redis`, `mq`, `app` — DNS‑имена внутри одной сети;
- `app` ходит по этим именам, не завязываясь на IP.

---

## Как это помогает в service discovery

В простых стендах встроенный DNS Docker — уже минимальный service discovery:

- сервисы находят друг друга по стабильным именам;
- можно менять версии и пересоздавать контейнеры, не трогая конфиги клиентов;
- можно использовать алиасы (`db`, `cache`) и подменять за ними конкретные контейнеры.

Дальше, с ростом инфраструктуры:

- на уровне Docker Compose / Swarm / K8s подключаются более сложные механизмы discovery;
- но базовая идея остаётся: «не IP, а имя сервиса».

---

## Практические рекомендации

- Всегда использовать **user-defined bridge‑сети**, а не дефолтную `bridge` для многоконтейнерных приложений.
- Во всех конфигурациях указывать hostnames сервисов (`db`, `redis`, `mq`), а не IP‑адреса.
- Использовать `--network-alias` там, где нужно абстрагировать потребителей от конкретного имени контейнера.
- В compose использовать имена сервисов как базовые DNS‑имена и не плодить лишние ручные настройки.
