# Основы Docker-образов: структура, pull/push, теги, локальный кэш и семантическое тегирование

## Что такое Docker-образ

Docker-образ — это неизменяемый слоистый шаблон файловой системы с метаданными о запуске.
Он хранит всё, что нужно для старта приложения: бинарники, зависимости, конфигурацию, стартовую команду.
Контейнер создаётся из образа как процесс, использующий эти слои в режиме copy-on-write.

Ключевые свойства:

* слои создаются инструкциями Dockerfile и накладываются друг на друга;
* слои не меняются после сборки;
* разные образы могут переиспользовать одинаковые слои;
* идентификатор образа — это `name:tag`, а в основе лежит digest (sha256).

Пример сборки:

```
docker build -t my-service:1.2.0 .
```

---

## Как устроены слои образа

Каждая инструкция Dockerfile формирует новый слой.
Инструкции, создающие новый слой: `FROM`, `RUN`, `COPY`, `ADD`.
Инструкции, не создающие слой: `ENV`, `LABEL`, `EXPOSE`, `CMD`, `ENTRYPOINT`.

Слой — это tar-архив с изменениями относительно предыдущего слоя.
Файловая система контейнера собирается наложением слоёв в overlay-fs.

Пользователь видит итоговую файловую систему, но Docker хранит каждый слой отдельно и кэширует его.

---

## Локальный кэш образов

Docker использует локальный кэш для ускорения сборок и экономии трафика.

Механика кэша:

* если инструкция Dockerfile совпадает (контекст, команда, файлы), Docker использует ранее собранный слой;
* изменение одного файла в COPY или RUN инвалидирует слой и все последующие;
* кэш живёт в одном общем хранилище, слои разных образов могут быть общими.

Кэш — причина, почему сборка иногда идёт мгновенно, а иногда пересобирает половину Dockerfile.

Просмотр локальных образов:

```
docker images
```

Удаление лишнего:

```
docker image prune
docker system prune
```

---

## Pull: загрузка образов

Pull — операция получения слоёв образа из registry на локальный хост.

Команда:

```
docker pull nginx:alpine
```

Поведение:

* Docker сравнивает локальные слои с удалёнными;
* скачивает только отсутствующие или изменённые слои;
* проверяет digest, чтобы гарантировать точность;
* сохраняет слои в локальном хранилище.

Registry не хранит каждый образ как файлик. Registry хранит манифесты и слои.
Pull — это скачивание нужного набора слоёв.

---

## Push: загрузка образов в registry

Push отправляет локально собранный образ в указанное registry.
Перед push обычно требуется retag:

```
docker tag my-service:1.2.0 registry.example.com/my-service:1.2.0
docker push registry.example.com/my-service:1.2.0
```

Поведение:

* Docker сравнивает локальные слои с теми, что уже есть в registry;
* загружает только отсутствующие слои;
* публикует манифест с тегом;
* registry начинает раздавать образ для pull.

Push — это не перезапись образов, а добавление нового тега, указывающего на набор слоёв и digest.

---

## Теги: как Docker идентифицирует образы

Тег — это удобное имя, указывающее на конкретный манифест, который указывает на digest и слои.

Формат:

```
name:tag
```

Тег может быть любым строковым значением: версия, дата, git-hash, окружение.
Отдельный тег не означает отдельный образ. Два тега могут указывать на один и тот же digest.

Проверка digest:

```
docker pull my-service:latest
docker inspect --format='{{.RepoDigests}}' my-service:latest
```

Digest — единственный надёжный идентификатор. Теги — ярлыки.

---

## Семантическое тегирование (semver)

Для backend-сервисов полезно использовать SemVer — схемы вида `MAJOR.MINOR.PATCH`.

Пример:

* `1.4.0` — новый функционал, обратная совместимость сохранена;
* `1.4.1` — мелкие фиксы без изменений API;
* `2.0.0` — несовместимые изменения.

Практика:

* immutable-теги: каждый номер версии публикуется лишь один раз;
* latest не нужен в проде, так как скрывает digest и ломает воспроизводимость;
* build-metadata полезно кодировать как `1.4.0+sha.abc123`.

Семантическое тегирование делает снапшоты предсказуемыми и повторяемыми в CI/CD.

---

## Итог

* Образ — слоистый неизменяемый шаблон.
* Pull — загрузка слоёв на машину.
* Push — публикация слоёв в registry.
* Тег — ярлык, digest — реальный идентификатор.
* Локальный кэш ускоряет сборку и уменьшает трафик.
* SemVer делает управление версиями контейнеров предсказуемым.
