# gRPC overview

> gRPC — это фреймворк для удалённого вызова процедур (RPC), который позволяет сервисам вызывать методы друг друга так, как будто это обычные локальные функции, при этом под капотом используется HTTP/2 и бинарная сериализация (обычно Protocol Buffers).  
> Он ориентирован на высокопроизводительное взаимодействие микросервисов, поддерживает стриминг, двунаправленную связь, таймауты, отмену запросов и кросс‑языковую совместимость.

---

## Что такое gRPC

gRPC расшифровывается как *g Remote Procedure Calls* и представляет собой систему удалённых вызовов процедур с открытым исходным кодом, изначально разработанную в Google. На уровне приложения это способ сделать сетевое взаимодействие максимально похожим на обычные вызовы функций: клиент вызывает метод интерфейса, а инфраструктура gRPC занимается сериализацией данных, отправкой по сети и получением ответа.

Основные опоры gRPC:

- HTTP/2 в качестве транспортного протокола
- Protocol Buffers (proto3) в качестве IDL и формата сериализации
- Автогенерация кода для клиента и сервера на разных языках

В качестве транспорта gRPC использует HTTP/2, а в качестве языка описания интерфейсов и формата сериализации чаще всего применяются Protocol Buffers (proto3). Это позволяет передавать данные в компактном бинарном виде, мультиплексировать несколько запросов по одному соединению и использовать возможности HTTP/2 вроде потоков, приоритизации и сжатия заголовков.

---

## RPC и идея «удалённой функции»

Классический RPC‑подход позволяет вызывать функцию на удалённом сервере так, как если бы она выполнялась локально. Клиентский код работает с обычным интерфейсом, а инфраструктура берёт на себя упаковку аргументов в сообщения, отправку по сети и распаковку результата.

Ключевая идея:

- с точки зрения приложения — «просто вызов метода»;
- с точки зрения сети — сериализация, пересылка и десериализация сообщений.

В gRPC на стороне клиента генерируется так называемый *stub* (клиент), который реализует методы, описанные в `.proto`‑контракте сервиса. Приложение вызывает методы этого клиента, а gRPC под капотом формирует запрос, отправляет его на сервер и возвращает ответ, скрывая детали HTTP/2 и сериализации.

---

## Клиент‑серверная модель

gRPC строится вокруг привычной клиент‑серверной архитектуры: сервер определяет сервисы и методы, которые доступны для удалённого вызова, а клиенты вызывают эти методы по сети. Реализация клиента и сервера может быть на разных языках, но при этом они опираются на один и тот же `.proto`‑контракт, что обеспечивает строгую типизацию и совместимость.

С точки зрения жизненного цикла вызова:

1. Клиент вызывает метод stub’а, формируя сообщение запроса и метаданные.
2. Сервер получает запрос, вызывает нужный метод реализации.
3. Сервер возвращает ответ + статус (успех/ошибка).
4. Клиент обрабатывает ответ и статус (в том числе сетевые ошибки, таймауты, отмену).

Клиент и сервер независимо трактуют успешность вызова: возможна ситуация, когда сервер считает вызов успешным, а клиент — завершившимся с ошибкой из‑за таймаута или обрыва соединения.

---

## Типы RPC в gRPC

gRPC поддерживает четыре основных типа RPC, которые покрывают большинство сценариев взаимодействия между сервисами.

### Unary RPC

Классическая модель «запрос‑ответ»: клиент отправляет одно сообщение и получает один ответ, как при обычном вызове функции. Это базовый тип и чаще всего используется в CRUD‑операциях и простых сервисах.

Типичные примеры:

- создание/получение/обновление сущности;
- авторизация, валидация токена;
- небольшие операции с быстрым ответом.

### Server streaming RPC

Клиент отправляет один запрос и получает поток сообщений от сервера. Клиент читает из потока до тех пор, пока сервер не закончит отправку и не закроет stream, что удобно для передачи больших наборов данных частями.

Подходит для:

- выдачи длинных списков (логов, записей, результатов поиска);
- выгрузки отчётов;
- отправки прогресса длительных операций.

### Client streaming RPC

Клиент отправляет последовательность сообщений в поток, затем закрывает его и ждёт один ответ от сервера. Такой режим полезен, когда нужно агрегировать или обрабатывать на сервере большое количество входных событий или чанков данных.

Подходит для:

- загрузки больших файлов чанками;
- отправки потока метрик/событий для последующей агрегации;
- батч‑обработки данных, когда ответ нужен только по итогам.

### Bidirectional streaming RPC

Обе стороны обмениваются последовательностями сообщений в одном двунаправленном потоке, причём читать и писать можно в любом порядке. Это подходит для чатов, long‑lived соединений, online‑обработки и сценариев с активным обменом состоянием.

Примеры сценариев:

- чаты и уведомления в реальном времени;
- online‑игры и координация состояний;
- стриминг телеметрии с интерактивной реакцией сервера.

---

## Ключевые особенности по сравнению с REST

### Протокол и формат данных

В отличие от типичного REST‑подхода поверх HTTP/1.1 и JSON, gRPC использует:

- HTTP/2:
    - мультиплексирование нескольких запросов по одному соединению;
    - сжатие заголовков;
    - server push (в том числе для стриминга).
- Protocol Buffers:
    - компактный бинарный формат;
    - строгая схема в `.proto`‑файлах;
    - автогенерация кода для разных языков.

Это даёт преимущества по размеру сообщений, скорости сериализации и возможности мультиплексировать множество запросов по одному TCP‑соединению.

### Контракты и генерация кода

Благодаря генерации кода по контракту gRPC облегчает кросс‑языковое взаимодействие и снижает количество ручного клей‑кода. `.proto`‑файл — это единый источник правды для:

- описания сервисов и методов;
- описания сообщений и их полей;
- генерации серверных интерфейсов и клиентских stub’ов.

При этом gRPC чаще всего используется для внутренних сервис‑to‑service взаимодействий; для внешних публичных API по‑прежнему нередко выбирают REST/JSON или комбинируют gRPC с HTTP/JSON‑gateway.

---

## Где gRPC особенно полезен

gRPC хорошо подходит для микросервисных архитектур, где важны:

- производительность и низкая латентность;
- строгие схемы и контроль эволюции контрактов;
- взаимодействие между многими сервисами на разных языках.

Он широко используется в системах с высокой нагрузкой, real‑time‑взаимодействием и стримингом данных, а также там, где нужно эффективно связывать сервисы, написанные на разных языках.

Благодаря поддержке:

- таймаутов и отмены запросов,
- стриминга (в обе стороны),
- метаданных (для авторизации, трейсинга и т.п.),
