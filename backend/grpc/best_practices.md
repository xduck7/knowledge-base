# gRPC best practices

> Здесь собраны практики, которые помогают делать gRPC‑сервисы предсказуемыми, стабильными и удобными в сопровождении.

---

## Дизайн API и `.proto`

### Контракты

- Продумывай **границы сервисов**: один сервис = одна бизнес‑область (UserService, BillingService, AuthService), а не «God‑Service».
- Всегда **версионируй** API через package и пути файлов: `example.users.v1`, `example.users.v2`.
- Для каждого RPC — свои `*Request` и `*Response`, не переиспользуй один и тот же message в десятке методов.

### Сообщения

- Имя сообщений — [translate:PascalCase] ([translate:GetUserRequest], [translate:GetUserResponse], [translate:User]); поля — [translate:snake_case] (`user_id`, `created_at`).
- Не клади в одно сообщение всё подряд: лучше несколько маленьких DTO, чем один гигантский «мешок».
- Используй well‑known types: `google.protobuf.Timestamp`, `Duration`, `Empty`, wrapper‑типы для nullable.

---

## Сетевое взаимодействие и ресурсы

### Соединения и клиенты

- **Не создавай канал/клиента на каждый запрос**.  
  Создай `grpc.ClientConn` один раз и переиспользуй; при необходимости — пул из нескольких коннектов.
- Настраивай таймауты и дедлайны на каждом вызове (`context.WithTimeout`), особенно в публичных API.
- Разделяй критичные и «шумные» клиенты по разным коннектам (например, логгер/трейсер в отдельном канале).

### Стриминг vs unary

- Для большого объёма данных или real‑time лучше использовать **streaming**:
  - server‑streaming для выдачи больших выборок;
  - client‑streaming для загрузки чанков;
  - bidi‑streaming для чатов и онлайн‑каналов.
- Не усложняй без нужды: если запрос маленький и одноразовый — оставляй unary.

---

## Ошибки и UX клиента

### gRPC‑коды

- Используй корректные `codes.*`:
  - `InvalidArgument` для валидации;
  - `NotFound` для отсутствующих ресурсов;
  - `Unauthenticated` / `PermissionDenied` для auth/authz;
  - `Unavailable` / `DeadlineExceeded` для временных сбоев;
  - `Internal` только для настоящих внутренних ошибок.
- Не зашивай ошибки в поля ответа — используй статус и, при необходимости, `ErrorDetails`.

### Retry и идемпотентность

- Чётко разделяй:
  - ошибки, которые **не стоит** ретраить (валидация, права, not found);
  - ошибки, которые можно (временная недоступность, таймаут).
- Идемпотентные операции (например, создание с idempotency‑key) проще и безопаснее ретраить.
- Retry‑логику выносить в клиентский слой/интерсепторы, а не размазывать по бизнес‑коду.

---

## Безопасность

- Всегда используй **TLS** как минимум на внешней границе; для внутреннего трафика — TLS или mTLS, особенно в zero‑trust окружениях.
- Для аутентификации:
  - сервисы между собой — mTLS или сервисные токены;
  - пользователи — OAuth2/OIDC, JWT в `authorization: Bearer ...`.
- Auth‑проверки держать в интерсепторах/политиках (RBAC/ABAC), а бизнес‑методы считать «уже аутентифицированными».

---

## Observability и дебаг

- Логирование, метрики и трейсинг подключать через **interceptors** на клиенте и сервере:
  - логировать метод, код, latency, trace‑id;
  - собирать метрики RPS, latency, error rate, payload size;
  - прокидывать trace‑контекст через metadata.
- Привязывать observability к gRPC‑понятиям: `service`, `method`, `code`, а не только к HTTP‑уровню.
- Использовать стандартный gRPC‑health‑check для интеграции с Kubernetes/балансировщиками.

---

## Производительность

- Минимизируй размер сообщений:
  - избегай избыточных полей;
  - не таскай лишние вложенные структуры, которые можно запросить отдельным RPC.
- Используй стриминг вместо огромных unary‑ответов.
- Разумно настраивай:
  - максимальный размер сообщения;
  - keepalive;
  - concurrency‑лимиты (количество одновременных стримов/запросов).

---

## Load balancing и устойчивость

- Не полагайся только на L4‑балансировщик с одним длительным HTTP/2‑коннектом: используй client‑side LB или L7‑прокси.
- Обязательно учитывай **health‑сигналы** при балансировке (статус SERVING / NOT_SERVING).
- Для критичных зависимостей добавляй:
  - таймауты;
  - retry (с backoff);
  - circuit breaker в виде отдельного слоя/интерсептора.

---

## Организация кода и репозитория

- Отделяй:
  - `.proto` → `proto/`;
  - сгенерированный код → `gen/` (не правится руками);
  - бизнес‑логику → `internal/` или `pkg/`.
- Генерацию кода автоматизируй:
  - `Makefile` таргет (`make proto`);
  - или `go generate`;
  - проверку актуальности — в CI.
- Сервера и клиенты строить поверх сгенерированных интерфейсов: **никакого ручного копирования структур**.

---

## DX (Developer Experience)

- Пиши человекочитаемые имена сервисов, методов и сообщений: из названия должно быть понятно, что делает метод.
- Документируй контракты:
  - комментарии прямо в `.proto`;
  - таблицы кодов ошибок и их смысл;
  - ожидания по таймаутам, идемпотентности и ретраям.
- Делай примеры использования (client snippets) для типичных языков в README/docs.

---

## Краткий чек‑лист

- [ ] Версионирование пакетов (`*.v1`, `*.v2`) и чёткие границы сервисов.  
- [ ] Адекватные коды ошибок и единый подход к error handling.  
- [ ] TLS/mTLS + токены/JWT для auth, интерсепторы для authz.  
- [ ] Observability с первого дня: логи, метрики, трейсы, health‑check.  
- [ ] Переиспользование каналов, продуманный streaming и лимиты.  
- [ ] Автоматизированная генерация кода и чистая структура репозитория.  
- [ ] Документация по API и общей политике retry/timeout/idempotency.