# WebSocket: производительность и надёжность

## 1. Best practices по производительности

### Формат данных и размер payload

- Чем меньше и проще сообщение, тем лучше: убирай лишние поля, не шли огромные JSON‑объекты, если их можно разделить или сжать.
- Для высоких нагрузок стоит рассмотреть бинарные форматы (protobuf, MessagePack, Avro) вместо «толстого» JSON: меньше байт по сети и быстрее сериализация/десериализация.
- Если фронт на JS/TS, можно начать с JSON, но держать протокол так, чтобы перейти на бинарный формат без массового переписывания логики.

### Частота обновлений, батчинг и дебаунс

- Слишком частые сообщения убивают и сервер, и сеть, особенно на мобильных устройствах.
- Там, где это возможно, делай батчинг: вместо 100 сообщений по одному событию — 1 сообщение с массивом событий.
- Для «шумных» источников (например, поток обновлений позиций) используй дебаунс/троттлинг: слать обновления раз в N миллисекунд или по изменению выше порога.

### Компрессия

- WebSocket поддерживает расширение `permessage-deflate`: оно сильно экономит трафик на больших JSON‑ах и потоках текстовых сообщений.
- Компрессия — баланс между CPU и сетью: включай её там, где полезная нагрузка достаточно большая и повторяющаяся; для маленьких и частых сообщений иногда выгоднее отключить компрессию.
- Имеет смысл настраивать компрессию отдельно для разных типов каналов (например, включить для лент/историй, выключить для коротких команд и пингов).

### Оптимизация на стороне сервера

- Избегай блокирующих операций в «горячем» пути отправки сообщений (БД, медленные HTTP‑запросы); выносишь их в фоновые воркеры, очередь/брокер.
- На каждое соединение — отдельный «писатель» (goroutine, coroutine, task), который последовательно отправляет сообщения, принимая их из очереди; медленный клиент тогда тормозит только свою очередь, а не всех.
- Следи за выделением памяти: переиспользование буферов, аккуратность с копированием больших структур, профилирование под реальной нагрузкой.

---

## 2. Управление соединениями

### Лимиты подключений

- Лимитируй количество соединений:
    - на узел (instance);
    - на IP;
    - на пользователя/токен/организацию.
- При превышении лимитов лучше явно отказать в новом соединении с понятной ошибкой, чем упасть «всем кластером».
- Для публичных API часто вводят тарифы/квоты по коннектам и сообщениям, завязанные на план/ключ.

### Keep‑alive, ping/pong и таймауты

- Используй протокольный ping/pong WebSocket, чтобы:
    - обнаруживать «мертвые» соединения за NAT/прокси;
    - не держать навсегда старые сессии после потери сети.
- Типовые настройки:
    - ping раз в 15–30 секунд;
    - таймаут ответа 30–60 секунд;
    - после нескольких пропущенных pong — закрытие соединения.
- Отдельно можно делать application‑level heartbeat (например, «я жив, и у меня нет ошибок») с более богатой информацией.

### Восстановление соединений и backoff

- Соединения в реальном мире падают: мобильная сеть, Wi‑Fi, sleep устройства. Клиент должен:
    - различать нормальное закрытие (user logout, явный close) и ошибочное (network error, таймаут);
    - пытаться переподключаться автоматически, но не создавать DDoS.
- Используй экспоненциальный backoff (например, 0.5s → 1s → 2s → 5s → 10s с max‑потолком и джиттером), чтобы:
    - не бомбить сервер при массовом падении;
    - разнести переподключения клиентов по времени.

---

## 3. Обработка ошибок и сценарии реконнекта

### Коды закрытия и причины

- WebSocket имеет стандартные коды закрытия (например, 1000 — нормальное завершение, 1001 — «уходим», 1008 — нарушение политики, 1011 — внутренняя ошибка).
- Используй коды и reason‑строку осознанно:
    - клиент понимает, надо ли пытаться реконнектиться;
    - помогает при дебаге и в логах.
- Для бизнес‑ошибок (например, «нет права на канал», «тариф исчерпан») удобно использовать:
    - либо специальные коды/причины закрытия;
    - либо отдельное сообщение‑ошибку и только потом закрытие.

### Ошибки на клиенте

- Клиентская сторона должна:
    - логировать ошибки `onerror` и `onclose` с кодами;
    - уметь отличать «ошибка протокола/авторизации» от «сетевой глюк»;
    - в случае постоянных auth‑ошибок (401/403‑эквиваленты) не пытаться бесконечно переподключаться.
- Удобно иметь единый «клиент WebSocket» как обёртку:
    - скрывает логику backoff;
    - умеет восстанавливать подписки после реконнекта;
    - даёт единый интерфейс `subscribe / unsubscribe / publish`.

### Ошибки на сервере

- На сервере:
    - все ошибки чтения/записи по соединению — повод корректно закрыть сокет и освободить ресурсы;
    - неожиданные паники/исключения внутри обработчиков сообщений должны приводить к безопасному закрытию конкретного соединения, а не падению процесса.
- Ошибки, связанные с лимитами (слишком большой payload, слишком много сообщений), лучше логировать с отдельным типом и, при необходимости, сигнализировать системе защиты от злоупотреблений.

---

## 4. Наблюдаемость и метрики

### Метрики

Минимальный набор метрик для WebSocket‑слоя:

- Соединения:
    - текущее количество открытых соединений;
    - распределение по инстансам, юзерам, организациям, регионам.
- Трафик:
    - количество исходящих/входящих сообщений в секунду;
    - средний/максимальный размер сообщения;
    - распределение по типам сообщений/каналам.
- Ошибки:
    - количество ошибок рукопожатия/апгрейда;
    - количество закрытий по ошибке (коды, причины);
    - срабатывания rate‑limit/лимитов по ресурсам.
- Время:
    - latency обработки сообщения (от приёма до отправки);
    - задержка доставки событий от брокера до клиента.

### Логи и трассировки

- Логи:
    - логируй connect, auth, subscribe/unsubscribe, error, disconnect (с кодом и reason);
    - избегай логирования чувствительных данных (токены, полные payload’ы).
- Трассировки:
    - при наличии распределённого трейсинга полезно цеплять trace‑id к WebSocket‑сообщениям;
    - тогда можно увидеть путь события: БД → сервис → брокер → WS‑узел → клиент.

### Корреляция с HTTP/gRPC

- WebSocket обычно живёт рядом с REST/gRPC. Полезно уметь связывать:
    - HTTP‑запросы (например, POST /orders)
    - и события, пришедшие по WebSocket (обновления ордера).
- Это делается через:
    - общий trace‑id/correlation‑id;
    - либо через более простой логический ключ (orderId, userId) в логах и метриках.

---

## 5. Как это свести в документацию

Если продолжать стиль твоего репозитория, можно сделать один файл `websocket/performance-and-reliability.md` со структурой:

- Введение
- Оптимизация payload и форматов
- Управление частотой сообщений (батчинг, дебаунс)
- Компрессия и её trade‑offs
- Лимиты и управление соединениями (ping/pong, таймауты, backoff)
- Обработка ошибок и сценарии реконнекта (client/server)
- Наблюдаемость: метрики, логи, трассировки, корреляция с HTTP/gRPC
