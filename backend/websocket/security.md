# WebSocket: безопасность

## 1. Базовые принципы безопасности

### WSS и TLS‑терминация

- Всегда используй `wss://` в проде: это WebSocket поверх TLS, аналог HTTPS для HTTP.
- TLS можно терминировать на балансировщике (Nginx/Ingress/Envoy) или на самом WS‑сервисе; важно, чтобы трафик по внешней сети был шифрован, а внутренние hop’ы были либо тоже под TLS, либо в доверенной сети.
- Следи за актуальностью сертификатов (Let's Encrypt/ACME), настрой автоматическое обновление и перезагрузку конфигурации.

### Заголовки и защита от MITM

- Защита от MITM обеспечивается за счёт TLS: корректно настроенные сертификаты, строгая проверка hostname и отсутствие устаревших шифросьютов.
- На фронте можно использовать HSTS (через обычный HTTPS‑ответ), чтобы браузер всегда ходил только по HTTPS/WSS.
- Для веб‑клиентов не храни чувствительные токены в месте, доступном для JS (локальное хранилище), если есть риск XSS: безопаснее использовать `HttpOnly`‑cookies с ограничениями по домену/пути.

### CORS и Origin‑проверка

- WebSocket не использует CORS так же, как `fetch`, но браузер отправляет заголовок `Origin` при рукопожатии.
- На сервере явно проверяй `Origin` и разрешай только доверенные фронты; запросы с неизвестного `Origin` отклоняй.
- Если у тебя несколько окружений (prod/stage/dev), поддерживай белый список `Origin` через конфиг, а не хардкод.

---

## 2. Аутентификация и авторизация

### Варианты передачи токена

Основная идея: сначала клиент получает токен любым стандартным способом (логин/пароль, OAuth, SSO), а потом использует его при установке WS‑соединения.

Популярные схемы:

- **Cookies (session / JWT)**
    - Браузер автоматически отправляет cookies при HTTP‑запросе апгрейда.
    - Плюсы: удобно для классических веб‑приложений.
    - Минусы: нужно защищать от CSRF (привязка к Origin, `SameSite`, возможно — дополнительный CSRF‑токен в URL/сообщении).

- **Bearer/JWT‑токен в query‑параметре**
    - `wss://api.example.com/ws?token=...`
    - Плюсы: работает с голым WebSocket‑API в браузере.
    - Минусы: токен попадает в логи, историю, может светиться в URL‑ах, поэтому делай его короткоживущим (типа ticket на одно соединение).

- **Bearer/JWT в заголовке Authorization**
    - Стандартный HTTP‑способ, но нативный браузерный `WebSocket` не даёт задать произвольные заголовки.
    - Подходит для нативных приложений, CLI, мобильных SDK и кастомных JS‑клиентов (через библиотеки, которые умеют прокидывать заголовки).

- **Ticket/one‑time token**
    - Клиент делает обычный HTTP‑запрос, получает одноразовый ticket, далее использует его как query‑параметр или в subprotocol.
    - Можно привязать ticket к пользователю, Scope’ам и времени жизни; ticket живёт минуту и годится только для одного соединения.

- **Первое сообщение после соединения**
    - Соединение поднимается «анонимным», а первым сообщением клиент отправляет `{type: "auth", token: "..."}`.
    - Сервер валидирует токен и помечает соединение как аутентифицированное; до этого любые сообщения либо запрещены, либо сильно ограничены.

### Привязка пользователя к соединению

На стороне сервера:

- После успешной аутентификации привяжи к соединению идентификатор пользователя/клиента, набор ролей/Scope’ов и возможные ограничения (лимиты, списки доступных room/каналов).
- Храни мапу `userID -> [connections...]`, чтобы уметь:
    - отправлять персональные сообщения на все активные коннекты пользователя;
    - разорвать все соединения пользователя при logout/отзыве токена;
    - применять лимиты на количество одновременно открытых коннектов.

### ACL и роль‑based доступ

- На уровне доменной логики определяй права: кто может подписаться на какой канал, комнату, документ, ордер‑стрим и т.п.
- Любой subscribe/unsubscribe‑запрос через WebSocket обрабатывай так же строго, как обычный HTTP‑запрос:
    - проверка токена;
    - проверка ролей/Scope’ов;
    - проверка принадлежности ресурса пользователю/организации.
- Для сложных сценариев можно использовать политику типа ABAC/RBAC: роль + атрибуты объекта (owner, orgID, флаги приватности).

---

## 3. Типичные угрозы и защиты

### Injection в сообщениях

- WebSocket — это просто транспорт, поэтому все стандартные проблемы (SQL‑injection, XSS, template‑injection) полностью актуальны.
- Никогда не подставляй данные из сообщений напрямую в SQL, шаблоны или eval.
- Валидируй/схемизируй payload (JSON‑schema, protobuf, strict DTO) и централизованно фильтруй/экранируй опасные поля.

### DoS и злоупотребление подключениями

- Ограничивай максимальное количество одновременных коннектов:
    - глобально на инстанс;
    - на IP;
    - на userID.
- Вводи rate limit на количество сообщений в секунду/минуту от одного клиента, а также лимиты на размер сообщения.
- При превышении лимита — сначала отдавай ошибку/предупреждение, при систематическом нарушении — закрывай соединение и логируй.

### Abuse ping/pong и удержание ресурсов

- Клиент может пытаться искусственно держать соединение, спамя ping/pong или периодически посылая мусорные сообщения.
- Вводи:
    - таймаут бездействия (idle timeout);
    - максимальное время жизни соединения (connection TTL) для некоторых типов клиентов;
    - проверку интервала ping/pong, отклоняя аномально частые пинги.

### Утечки ресурсов

- На каждое соединение — лимит по:
    - размеру очереди исходящих сообщений;
    - выделенным буферам;
    - количеству «подписок» на комнаты/каналы.
- При закрытии соединения обязательно:
    - удаляй его из всех мап и групп;
    - освобождай таймеры, context’ы, goroutine’ы или эквиваленты в другом языке;
    - снимай любые блокировки/захваты.

### Проверка ввода

- Валидация схемы и типов должна быть первой стадией обработки: если сообщение не соответствует ожидаемой структуре — сразу error/close.
- Не позволяй клиенту управлять тем, что не должно контролироваться пользователем (например, явный `userId` в сообщении, если его уже знаешь из токена).

---

## 4. Чеклист безопасности для ревью

Ниже — компактный чеклист, который можно использовать как основу для `websocket/security-checklist.md`.

### TLS и транспорт

- [ ] Внешние подключения только по `wss://`, TLS включён и настроен.
- [ ] Используются актуальные протоколы и шифросьюты, сертификаты обновляются автоматически.
- [ ] HSTS включён на домене (через HTTPS‑ответы).

### Аутентификация и авторизация

- [ ] Все соединения проходят аутентификацию (cookies / JWT / ticket / другое).
- [ ] Токены короткоживущие, при необходимости есть механизм refresh/ротации.
- [ ] Каждый subscribe/publish‑экшен проходит проверку прав (RBAC/ABAC).
- [ ] Есть возможность принудительно разорвать соединения по пользователю/токену.

### Rate limits и ограничения

- [ ] Есть лимиты на количество соединений на user/IP/инстанс.
- [ ] Есть rate limit на сообщения и лимиты на размер payload.
- [ ] Реализован backpressure: ограничение очередей, политика дропа/закрытия.

### Заголовки, Origin и CSRF

- [ ] Проверяется `Origin`, разрешены только доверенные фронтенды.
- [ ] Если используется cookie‑auth, настроены `Secure`, `HttpOnly`, `SameSite`.
- [ ] Чувствительные токены не светятся в логах/URL (по возможности).

### Логирование и алерты

- [ ] Логируются ключевые события: connect, auth success/fail, subscribe, rate‑limit, disconnect с кодами причин.
- [ ] Настроены алерты по аномалиям (скачок числа коннектов, ошибок, rate‑limit срабатываний).
- [ ] Есть базовый аудит действий (кто, когда, куда подписался/что отправил) в пределах разумного.

### Код и протокол

- [ ] Все входящие сообщения валидируются по схеме/типам.
- [ ] Никаких raw‑SQL/шаблонов без параметризации и экранирования.
- [ ] Не используется динамический eval/интерпретация данных от клиента.